# TERRA SIM - DOKUMENTASI LENGKAP DATA DAN ALUR APLIKASI (BAGIAN 2)

## DAFTAR ISI
1. [Data Struktur Backend](#data-struktur-backend)
2. [API Endpoints](#api-endpoints)
3. [Alur Data Backend](#alur-data-backend)

---

## DATA STRUKTUR BACKEND

### 1. Input Data Structure (Pydantic Models)
**File**: `backend/input_data.py` (line 1-50)

```python
class Point(BaseModel):
    x: float          # X coordinate (meters)
    y: float          # Y coordinate (meters)

class Material(BaseModel):
    id: str           # Material ID
    name: str         # Material name
    color: str        # Display color
    youngs_modulus: float           # Young's modulus (kN/m²)
    poissons_ratio: float           # Poisson's ratio
    unit_weight_saturated: float    # Saturated unit weight (kN/m³)
    unit_weight_unsaturated: float  # Unsaturated unit weight (kN/m³)
    cohesion: float                 # Cohesion (kN/m²)
    friction_angle: float           # Friction angle (degrees)
    dilation_angle: float           # Dilation angle (degrees)
    thickness: float                # Thickness (m)
    permeability: float             # Permeability (m/s)
    void_ratio: float               # Void ratio
    specific_gravity: float         # Specific gravity

class PointLoad(BaseModel):
    id: str           # Point load ID
    x: float          # X coordinate (meters)
    y: float          # Y coordinate (meters)
    fx: float         # Horizontal force (kN)
    fy: float         # Vertical force (kN)
    node: Optional[int] = None      # Assigned node ID

class WaterLevel(BaseModel):
    id: str           # Water level ID
    points: List[Point]             # Water level polyline points
    is_active: bool   # Active status

class Polygon(BaseModel):
    vertices: List[Point]           # Polygon vertices
    mesh_size: float                # Target mesh size
    boundary_refinement_factor: float # Boundary refinement factor
    id: Optional[str] = None        # Polygon ID
    material_id: Optional[str] = None # Assigned material ID

class Stage(BaseModel):
    id: str           # Stage ID
    name: str         # Stage name
    active_polygons: List[str]      # Active polygon IDs
    active_point_loads: List[str]   # Active point load IDs
    active_water_levels: List[str]  # Active water level IDs
    calculation_type: str           # Analysis type ('FEA' or 'K0')
```

**Sumber Data**: 
- Received from frontend via API endpoints
- Validated using Pydantic models
- Used in mesh generation and analysis

**Contoh Data**:
```json
{
    "x": 0.0,
    "y": 0.0
}
```

```json
{
    "id": "clay_1",
    "name": "Soft Clay",
    "color": "#8B4513",
    "youngs_modulus": 30000.0,
    "poissons_ratio": 0.3,
    "unit_weight_saturated": 22.0,
    "unit_weight_unsaturated": 20.0,
    "cohesion": 50.0,
    "friction_angle": 25.0,
    "dilation_angle": 0.0,
    "thickness": 1.0,
    "permeability": 1e-8,
    "void_ratio": 0.8,
    "specific_gravity": 2.7
}
```

### 2. Mesh Data Structure
**File**: `backend/mesh_generator.py` (line 20-50)

```python
class Node:
    def __init__(self, id: int, x: float, y: float):
        self.id = id        # Node ID (0-based for internal use)
        self.x = x          # X coordinate (meters)
        self.y = y          # Y coordinate (meters)

class Element:
    def __init__(self, id: int, nodes: List[int]):
        self.id = id        # Element ID (0-based for internal use)
        self.nodes = nodes  # List of node IDs [node1, node2, node3]
        self.active = True  # Element active status

class BoundaryCondition:
    def __init__(self, node_id: int, bc_type: str):
        self.node_id = node_id  # Node ID
        self.bc_type = bc_type  # 'full_fixed' or 'normal_fixed'
```

**Sumber Data**: 
- Generated by mesh_generator.py from polygon vertices
- Used in FEA solver for stiffness matrix assembly

**Contoh Data**:
```python
# Node
Node(id=0, x=0.0, y=0.0)

# Element
Element(id=0, nodes=[0, 1, 10])

# Boundary Condition
BoundaryCondition(node_id=0, bc_type='full_fixed')
```

### 3. FEA Solver Data Structure
**File**: `backend/fea_solver.py` (line 10-100)

```python
class FEASolver:
    def __init__(self):
        self.nodes = []              # List of Node objects
        self.elements = []           # List of Element objects
        self.materials = {}          # Dict: material_id -> Material
        self.element_materials = {}  # Dict: element_id -> Material
        self.boundary_conditions = [] # List of BoundaryCondition objects
        self.loads = {}              # Dict: node_id -> [fx, fy]
        self.K = None                # Global stiffness matrix
        self.F = None                # Global force vector
        self.U = None                # Global displacement vector
        self.stress_results = {}     # Dict: element_id -> stress data
        self.strain_results = {}     # Dict: element_id -> strain data
```

**Sumber Data**: 
- Initialized from mesh data and material properties
- Updated during analysis process
- Results stored in stress_results and strain_results

### 4. CST Element Data Structure
**File**: `backend/cst_element.py` (line 1-50)

```python
class CSTElement:
    def __init__(self, nodes: List[Node], material: Material):
        self.nodes = nodes           # List of 3 Node objects
        self.material = material     # Material object
        self.B = None                # Strain-displacement matrix
        self.D = None                # Constitutive matrix
        self.Ke = None               # Element stiffness matrix
        self.area = None             # Element area
        self.stress = None           # Element stress [σx, σy, τxy]
        self.strain = None           # Element strain [εx, εy, γxy]
```

**Sumber Data**: 
- Created for each element during analysis
- Contains element-specific matrices and results

### 5. K0 Solver Data Structure
**File**: `backend/k0_solver.py` (line 10-50)

```python
class K0Solver:
    def __init__(self, materials: Dict[str, Material], 
                 element_materials: Dict[int, Material],
                 water_levels: List[WaterLevel]):
        self.materials = materials           # Material properties
        self.element_materials = element_materials # Element-material mapping
        self.water_levels = water_levels     # Water level data
        self.k0_values = {}                  # Dict: material_id -> K0 value
        self.initial_stresses = {}           # Dict: element_id -> [σx, σy]
        self.pore_pressures = {}             # Dict: element_id -> pore pressure
```

**Sumber Data**: 
- Initialized from material properties and water levels
- Calculates K0 values and initial stresses

### 6. Sequential History Data Structure
**File**: `backend/sequential_history.py` (line 1-30)

```python
class SequentialHistory:
    def __init__(self):
        self.stages = []             # List of stage data
        self.results = {}            # Dict: stage_id -> analysis results
        self.element_states = {}     # Dict: element_id -> active status per stage
        self.load_history = {}       # Dict: stage_id -> load data
        self.displacement_history = {} # Dict: stage_id -> displacement data
```

**Sumber Data**: 
- Maintains history of sequential analysis
- Used for multi-stage construction simulation

---

## API ENDPOINTS

### 1. Generate Mesh Endpoint
**File**: `backend/api.py` (line 20-40)

```python
@app.post("/generate-mesh")
async def generate_mesh(
    polygons: List[Polygon],
    point_loads: List[PointLoad],
    water_levels: List[WaterLevel]
) -> Dict[str, Any]:
```

**Input Data**:
- `polygons`: List of polygon definitions
- `point_loads`: List of point load definitions  
- `water_levels`: List of water level definitions

**Output Data**:
```json
{
    "nodes": [
        {"id": 0, "x": 0.0, "y": 0.0},
        {"id": 1, "x": 0.5, "y": 0.0}
    ],
    "elements": [
        {"id": 0, "nodes": [0, 1, 10]},
        {"id": 1, "nodes": [1, 2, 11]}
    ],
    "boundary_conditions": {
        "full_fixed": [0, 1, 2],
        "normal_fixed": []
    },
    "loads": [
        {"node": 45, "fx": 0.0, "fy": -150.0}
    ]
}
```

**Sumber Data**: 
- Generated by mesh_generator.py
- Returns mesh data for frontend visualization

### 2. Run FEA Analysis Endpoint
**File**: `backend/api.py` (line 42-80)

```python
@app.post("/run-fea")
async def run_fea(
    nodes: List[Dict[str, Any]],
    elements: List[Dict[str, Any]],
    materials: List[Material],
    element_materials: List[Dict[str, Any]],
    boundary_conditions: Dict[str, List[int]],
    loads: List[Dict[str, Any]],
    water_levels: List[WaterLevel]
) -> Dict[str, Any]:
```

**Input Data**:
- `nodes`: List of node coordinates
- `elements`: List of element definitions
- `materials`: List of material properties
- `element_materials`: Element-material mapping
- `boundary_conditions`: Boundary condition definitions
- `loads`: Applied loads
- `water_levels`: Water level data

**Output Data**:
```json
{
    "displacements": [
        {
            "node_id": 0,
            "u": 0.0,
            "v": 0.0,
            "magnitude": 0.0
        }
    ],
    "element_results": [
        {
            "element_id": 0,
            "node_ids": [0, 1, 10],
            "strains": [0.0001, -0.0002, 0.00005],
            "stresses": [50.0, -100.0, 25.0],
            "principal_stresses": [75.0, -125.0],
            "total_stress_x": 50.0,
            "total_stress_y": -100.0,
            "effective_stress_x": 45.0,
            "effective_stress_y": -95.0,
            "effective_principal_stress_1": 70.0,
            "effective_principal_stress_3": -120.0,
            "pore_water_pressure": 5.0,
            "displacements": [0.0, 0.0, 0.0, -0.001, 0.0, 0.0]
        }
    ]
}
```

**Sumber Data**: 
- Calculated by fea_solver.py
- Returns analysis results for visualization

### 3. Run K0 Analysis Endpoint
**File**: `backend/api.py` (line 82-120)

```python
@app.post("/run-k0")
async def run_k0(
    materials: List[Material],
    element_materials: List[Dict[str, Any]],
    water_levels: List[WaterLevel],
    nodes: List[Dict[str, Any]],
    elements: List[Dict[str, Any]]
) -> Dict[str, Any]:
```

**Input Data**:
- `materials`: List of material properties
- `element_materials`: Element-material mapping
- `water_levels`: Water level data
- `nodes`: Node coordinates
- `elements`: Element definitions

**Output Data**:
```json
{
    "k0_values": {
        "clay_1": 0.5,
        "sand_1": 0.4
    },
    "initial_stresses": [
        {
            "element_id": 0,
            "sigma_x": 50.0,
            "sigma_y": 100.0,
            "pore_pressure": 5.0
        }
    ]
}
```

**Sumber Data**: 
- Calculated by k0_solver.py
- Returns K0 values and initial stresses

### 4. Sequential Analysis Endpoint
**File**: `backend/api.py` (line 122-160)

```python
@app.post("/run-sequential")
async def run_sequential(
    stages: List[Stage],
    nodes: List[Dict[str, Any]],
    elements: List[Dict[str, Any]],
    materials: List[Material],
    element_materials: List[Dict[str, Any]],
    boundary_conditions: Dict[str, List[int]],
    loads: List[Dict[str, Any]],
    water_levels: List[WaterLevel]
) -> Dict[str, Any]:
```

**Input Data**:
- `stages`: List of stage definitions
- All other data same as FEA endpoint

**Output Data**:
```json
{
    "stage_results": {
        "initial": {
            "displacements": [...],
            "element_results": [...]
        },
        "construction": {
            "displacements": [...],
            "element_results": [...]
        }
    }
}
```

**Sumber Data**: 
- Calculated by sequential_history.py
- Returns results for each stage

---

## ALUR DATA BACKEND

### 1. Mesh Generation Process
**File**: `backend/mesh_generator.py` (line 60-120)

```python
def generate_mesh(polygons: List[Polygon]) -> Tuple[List[Node], List[Element], List[BoundaryCondition]]:
    # 1. Extract polygon vertices
    # 2. Create triangulation using Triangle library
    # 3. Generate nodes and elements
    # 4. Apply boundary conditions
    # 5. Return mesh data
```

**Input**: Polygon definitions
**Output**: Nodes, elements, boundary conditions

### 2. FEA Analysis Process
**File**: `backend/fea_solver.py` (line 120-200)

```python
def solve(self) -> Dict[str, Any]:
    # 1. Assemble global stiffness matrix
    # 2. Apply boundary conditions
    # 3. Solve system of equations
    # 4. Calculate element stresses and strains
    # 5. Return results
```

**Input**: Mesh data, materials, loads, boundary conditions
**Output**: Displacements, stresses, strains

### 3. K0 Analysis Process
**File**: `backend/k0_solver.py` (line 60-120)

```python
def calculate_k0_stresses(self) -> Dict[str, Any]:
    # 1. Calculate K0 values for each material
    # 2. Calculate initial stresses
    # 3. Calculate pore water pressures
    # 4. Return K0 results
```

**Input**: Materials, water levels, mesh data
**Output**: K0 values, initial stresses, pore pressures

### 4. Sequential Analysis Process
**File**: `backend/sequential_history.py` (line 40-100)

```python
def run_sequential_analysis(self, stages: List[Stage]) -> Dict[str, Any]:
    # 1. Initialize history
    # 2. For each stage:
    #    - Update active elements
    #    - Update loads
    #    - Run FEA analysis
    #    - Store results
    # 3. Return stage results
```

**Input**: Stage definitions, mesh data, materials
**Output**: Results for each stage

---

## KESIMPULAN BAGIAN 2

Bagian 2 ini mencakup semua data struktur backend dan API endpoints yang digunakan dalam aplikasi TerraSim. Backend menggunakan Python dengan FastAPI untuk API endpoints dan berbagai solver untuk analisis geoteknik.

Data mengalir dari frontend melalui API endpoints, diproses oleh berbagai solver (mesh generation, FEA, K0), dan hasil dikirim kembali ke frontend untuk visualisasi.

Lanjut ke bagian 3 untuk dokumentasi komponen frontend dan alur integrasi.
